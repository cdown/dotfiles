alias grep='grep --color=auto'
alias vim='vim -u ~/.vimrc -N'
alias pbcopy='reattach-to-user-namespace pbcopy'
alias pbpaste='reattach-to-user-namespace pbpaste'
alias l='ls -laFh'
alias ls='ls --color=auto'
alias less='less -R'
alias mutt-patch='mutt -F ~/.config/mutt/rc-patch -H'
alias proxy='ssh -C2qTnN -D 1337'
alias rbenv-init='eval "$(rbenv init -)"'
alias sprunge='curl -F "sprunge=<-" http://sprunge.us'
alias sudo='sudo '
alias vbox-mods='sudo modprobe -a vboxdrv vboxnetadp vboxnetflt'
alias fixtime='sudo systemctl stop ntpd && sudo ntpdate 0.pool.ntp.org && sudo systemctl start ntpd'
alias b='bundle exec '

if [ "$(uname -s)" = Darwin ]; then
    command -v gls >/dev/null 2>&1 && alias ls='gls --color=auto'

    # Thanks for breaking LC_CTYPE, Apple
    alias ssh='LANG=en_US LC_ALL=en_US.UTF-8 ssh'
else
    alias ssh='TERM=rxvt-256color ssh'
fi

alias ga='git add'
alias gap='git add -p'
alias gb='git branch'
alias gbb='git branch -r --merged bugfixes@{u}'
alias gbm='git branch -r --merged master@{u}'
alias gbr='git branch -r'
alias gc='git commit -v'
alias gca='git commit -av'
alias gcaa='git commit --amend -av'
alias gco='git checkout'
alias gd='git diff --no-prefix'
alias gdb='gd bugfixes@{u}..'
alias gdc='gd --cached'
alias gdm='gd master@{u}..'
alias gdw='gd --color-words'
alias gfp='git fetch -p'
alias gfr='git fetch -p && git rebase -p @{u}'
alias gg='git grep'
alias gl='git log'
alias glb='git log --no-merges bugfixes@{u}..'
alias glm='git log --no-merges master@{u}..'
alias gmb='git merge --no-ff bugfixes@{u}'
alias gmm='git merge --no-ff master@{u}'
alias gp='git push'
alias grh='git reset --hard'
alias gru='git rebase -p @{u}'
alias gs='git show'
alias gst='git status'

alias udf='(
    set -e
    dir=$HOME/git/dotfiles
    cd "$dir"
    git stash -u
    git rebase -p @{u}
    git clean -dffx
    ./setup
)'

activate() { . "$1"/bin/activate; }
f() { find "${2-.}" -iwholename "*$1*"; }
yt() { mpv --cache 8096 "$(yturl "$@")"; }
ssh-context() { . ~/.ssh/agents/"$1" ; }
sbdl() { while ! rsync -avP --timeout 10 dian:/srv/rtorrent/data/"$1" .; do sleep 5; done; }

shr() ( ssh-context rmg >/dev/null; ssh "$@" )
shp() ( ssh-context personal >/dev/null; ssh "$@" )
shi() ( ssh-context iofc >/dev/null; ssh "$@" )

coa() {
    if [ "$1" ]; then
        tmux attach-session -d -t "$1" || tmux new-session -s "$1"
    else
        tmux ls
    fi
}

tar32() {
    if (( $# != 2 )); then
        printf 'Usage: %s [path] [dest]\n' "$0" >&2
        return 1
    fi

    local path="$1"
    local dest="$2"

    tar pczf "$path" "$path".tar.gz
    split -b 4095m "$path".tar.gz "$dest"/"${path##*/}".tar.gz.split.
    rm -- "$path".tar.gz
}

ytd() {
    local temp="$(mktemp -u)"
    curl -L -o "$temp" "$(yturl "$@")"
    printf '%s\n' "$temp"
}

owlman() {
    command owlman "$@"
    hash -r
}

zhutf8() {
    cp "$1"{,.orig}
    enca -c -x UTF8 -L zh "$1"
}

spoof() {
    local interface="${1-wlp18s0}"

    sudo netctl stop-all
    sudo ip link set dev "$interface" down
    sudo macchanger -r -b "$interface"
}

chromium-proxy() {
    pkill -f chromium
    proxy "$1" &
    sleep 5
    chromium --incognito --proxy-server=socks5://localhost:1337
    kill "$!"
}

ssh-dotfiles() {
    ssh "$@" 'rm -rf ~/git/dotfiles
    mkdir -p ~/git
    git clone https://github.com/cdown/dotfiles.git ~/git/dotfiles
    cd ~/git/dotfiles
    ./setup'
}

ssh-rev() {
    typeset -A ports
    ports[gopher]=2200
    ports[lakes]=2201

    port=${ports[$(hostname)]}

    autossh -M "$port"0 -v -- -R "$port":localhost:22 dian -N
}

record-screen() {
    ffmpeg \
        -f x11grab \
        -r 25 \
        -s "${2-$(xrandr --current | awk '$2 ~ /*/ { print $1 }')}" \
        -i :0.0+0,0 \
        -vcodec libx264 \
        -threads 0 \
        "$1"
}

freenode() {
    ssh -L 16000:irc.freenode.net:7000 dian -N &
    if [[ "$1" != --init-only ]]; then
        sleep 6
        irssi -c freenode-local
        kill "$!"
    fi
}

quakenet() {
    ssh -L 16001:irc.quakenet.org:6667 dian -N &
    if [[ "$1" != --init-only ]]; then
        sleep 6
        irssi -c quakenet-local
        kill "$!"
    fi
}

update-auth-sock() {
    local socket_path="$(tmux show-environment | sed -n 's/^SSH_AUTH_SOCK=//p')"

    if [[ -z "$socket_path" ]]; then
        echo 'no socket path' >&2
        return 1
    else
        export SSH_AUTH_SOCK="$socket_path"
    fi
}

so() {
    local tmpdir="$(mktemp -d)"
    local tmprc="$(mktemp)"
    cat > "$tmprc" << EOF
PS1='\$ '
cd "$tmpdir"
EOF
    env - HOME="$HOME" TERM="$TERM" bash --noprofile --rcfile "$tmprc"
    rm -r "$tmpdir" "$tmprc"
}

lol_homebrew() (
    cd -- "$(brew --prefix)"
    git fetch origin
    git reset --hard origin/master
    brew update
    brew upgrade
    brew list -1 | while read pkg; do
        brew unlink "$pkg"
        brew link "$pkg"
    done
)

git() {
    if [ "$1" = git ]; then
        # XXX: zsh bug? when aliasing with noglob around a function, it seems
        # $@ contains the function name
        shift
    fi

    if command git remote -v 2>/dev/null | grep -q cdown; then
        GIT_COMMITTER_EMAIL=chris@chrisdown.name GIT_AUTHOR_EMAIL=chris@chrisdown.name command git "$@"
    else
        command git "$@"
    fi
}

_git_prompt() {
    local branch
    local git_dir
    local tag

    if branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"; then
        if [[ $branch != HEAD ]]; then
            printf ':%s' "$branch"
        elif tag="$(git describe --tags --exact-match HEAD 2>/dev/null)"; then
            printf ':%s' "$tag"
        else
            printf ':%s' "$(git rev-parse --short HEAD)"
        fi

        git_dir=$(git rev-parse --git-dir)

        if [[ -d $git_dir/rebase-apply ]]; then
            printf ':%s' rebase
        elif [[ -d $git_dir/rebase-merge ]]; then
            printf ':%s' rebase
        elif [[ -f $git_dir/MERGE_HEAD ]]; then
            printf ':%s' merge
        elif [[ -f $git_dir/CHERRY_PICK_HEAD ]]; then
            printf ':%s' cherry-pick
        elif [[ -f $git_dir/REVERT_HEAD ]]; then
            printf ':%s' revert
        elif [[ -f $git_dir/BISECT_LOG ]]; then
            printf ':%s' bisect
        fi
    fi
}
