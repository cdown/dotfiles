#!/bin/bash -xe

if ! (( UID )); then
    echo "Please don't run this as root, things will break :-)" >&2
    exit 1
fi

exists() {
    command -v "$@" >/dev/null 2>&1
}

log_dir=/var/log/upgrades/$USER
name=$(LC_ALL=C date +%F-%T.%N)
log_file=$log_dir/$name
ansible_type_file=/.ansibletype

if [[ -f $ansible_type_file ]]; then
    read -r ansible_type < "$ansible_type_file"
else
    echo "WARNING: ansible type unset, guessing based on whether in X"
    if [[ $DISPLAY ]]; then
        ansible_type=desktop
    else
        ansible_type=server
    fi
    sudo tee <<< "$ansible_type" > /dev/null /.ansibletype
fi

sudo mkdir -p -m0700 "$log_dir"
sudo chown "$USER" "$log_dir"

if ! [[ -v TMUX ]]; then
    exec tmux new-session -s upgrade -- script -c "$0" "$log_file"
else
    session=$(tmux display-message -p '#S')
    tmux set-option -t "$session" remain-on-exit 1
fi

# /boot is not on btrfs root. Copy its contents to / so it will be included in
# the snapshot.
sudo mkdir -p /bootcopy
sudo rsync -avHAX /boot/ /bootcopy/

root_fs=$(df --output=fstype / | tail -1)
case $root_fs in
    btrfs)
        btrfs-snap / "upgrade-$name"

        # only keep 10 newest upgrade snapshots
        sudo btrfs subvolume list /snapshots/ |
            awk '$NF ~ /\/upgrade-/ { print "/" $NF }' |
            sort -r | tail -n +11 |
            xargs -r -d '\n' sudo btrfs subvolume delete -v
    ;;
    *)
        echo "WARNING: not creating btrfs snapshot as fs is not btrfs (it's $root_fs)" >&2
        sleep 5
    ;;
esac

for cmd in nodenv pyenv rbenv plenv; do
    exists "$cmd" || continue
    eval "$("$cmd" init -)"
done

cd /

if exists pyenv; then
    while read -r version; do
        export PYENV_VERSION="$version"
        pip install -U pip
        pipdeptree | grep -P '^\w+' | awk -F= '{ print $1 }' |
            xargs -d '\n' pip install -U
    done < ~/.python-version
fi

# This one is safe without checking for explicit dependencies >=2.6.1, see
# https://github.com/npm/npm/issues/6247
exists npm && npm update -g

# TODO: Check safety of gem update
exists gem && gem update

exists cpanm && cpan-outdated -p | cpanm -n

exists vagrant && vagrant plugin update

exists rustup && rustup update

while pkgs=$(pacman -Qqtd); do
    # All packages are spit by IFS.
    # shellcheck disable=SC2086
    sudo pacman -Rns $pkgs
done

while ! pkgs=$(find-possibly-manually-installed-packages "$ansible_type"); do
    # All packages are spit by IFS.
    # shellcheck disable=SC2086
    sudo pacman -Rns $pkgs
done

mapfile -t unowned < <(find-unowned-in-usr-bin)
(( "${#unowned[@]}" )) && sudo rm -i "${unowned[@]}"

if command -v pacaur >/dev/null 2>&1; then
    # Not sure why this is suddenly an issue, but need EDITOR=cat for
    # https://github.com/rmarquis/pacaur/commit/08bcfb8a92c8
    sudo -u makepkg EDITOR=cat pacaur --noconfirm --noedit -Syu
else
    sudo pacman --noconfirm -Syu
fi

sudo rm -f /etc/pacman.d/mirrorlist.pacnew /etc/locale.{conf,gen}.pacnew /etc/pulse/default.pa.pacnew /etc/pacman.conf.pacnew
sudo pacdiff

sudo update-from-cm "$ansible_type"

# This method is not guaranteed to work (eg. because it tries to extract the
# username from /home/X), but at least works for now. To make it more robust we
# should store the user list somewhere.
update-dotfiles
sudo -i -u root bin/update-dotfiles
for homedir in /home/*; do
    # This is quite brittle, we should consider moving this to Ansible
    user=${homedir##*/}
    # We must sudo to the user since their homedir might not be readable.
    if sudo -u "$user" bash -c '[[ -d $HOME/git/dotfiles ]]'; then
        # If we aren't using git://, we would would need an agent connection
        if sudo -i -u "$user" bash -c 'cd git/dotfiles && git remote -v | grep -q git://'; then
            sudo -i -u "$user" bin/update-dotfiles
        fi
    fi
done

